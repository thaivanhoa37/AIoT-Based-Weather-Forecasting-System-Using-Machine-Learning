<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bi·ªÉu ƒë·ªì & Ph√¢n t√≠ch - AIoT Weather</title>
    <link rel="stylesheet" href="/static/css/styles.css">
    <script src="/static/js/i18n.js"></script>
</head>

<body>
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="app-logo">
                <span class="logo-icon">üå§Ô∏è</span>
                <div>
                    <div class="app-title">AIoT Weather</div>
                    <div class="app-subtitle">AIoT-ML</div>
                </div>
            </div>
        </div>
        <nav>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="/" class="nav-link">
                        <span class="nav-icon">üè†</span>
                        <span data-i18n="nav.overview">T·ªïng quan</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="/charts" class="nav-link active">
                        <span class="nav-icon">üìä</span>
                        <span data-i18n="nav.charts">Bi·ªÉu ƒë·ªì & Ph√¢n t√≠ch</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="/forecast" class="nav-link">
                        <span class="nav-icon">ü§ñ</span>
                        <span data-i18n="nav.forecast">D·ª± b√°o (ML)</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="/ml-training" class="nav-link">
                        <span class="nav-icon">üöÄ</span>
                        <span data-i18n="nav.mlTraining">Hu·∫•n luy·ªán ML</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="/mysql" class="nav-link">
                        <span class="nav-icon">üíæ</span>
                        <span data-i18n="nav.mysql">Qu·∫£n l√Ω d·ªØ li·ªáu MySQL</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="/settings" class="nav-link">
                        <span class="nav-icon">‚öôÔ∏è</span>
                        <span data-i18n="nav.settings">C·∫•u h√¨nh h·ªá th·ªëng</span>
                    </a>
                </li>
            </ul>
        </nav>
    </aside>

    <!-- Main Content -->
    <div class="main-content" id="mainContent">
        <!-- Top Bar -->
        <header class="topbar">
            <div class="topbar-left">
                <button class="hamburger-btn" id="hamburgerBtn">‚ò∞</button>
                <h1 class="page-title" data-i18n="charts.pageTitle">Bi·ªÉu ƒë·ªì & Ph√¢n t√≠ch</h1>
            </div>
            <div class="topbar-right">
                <div class="clock-display">
                    <span class="clock-time" id="clockTime">00:00:00</span>
                    <span class="clock-label">GMT+7</span>
                </div>
                <div class="status-badge connected" id="mysqlStatus">
                    <span class="status-dot"></span> MySQL: Connected
                </div>
                <!-- Language Switcher -->
                <button class="lang-toggle-btn" id="langToggleBtn" onclick="toggleLanguage()" title="Switch Language">
                    <span class="lang-flag-toggle" id="langFlagVi">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 20" width="24" height="16">
                            <rect width="30" height="20" fill="#da251d"/>
                            <polygon points="15,4 11.47,14.85 20.71,8.15 9.29,8.15 18.53,14.85" fill="#ff0"/>
                        </svg>
                    </span>
                    <span class="lang-separator">|</span>
                    <span class="lang-flag-toggle" id="langFlagEn">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 30" width="24" height="16">
                            <clipPath id="s"><path d="M0,0 v30 h60 v-30 z"/></clipPath>
                            <clipPath id="t"><path d="M30,15 h30 v15 z v15 h-30 z h-30 v-15 z v-15 h30 z"/></clipPath>
                            <g clip-path="url(#s)"><path d="M0,0 v30 h60 v-30 z" fill="#012169"/>
                            <path d="M0,0 L60,30 M60,0 L0,30" stroke="#fff" stroke-width="6"/>
                            <path d="M0,0 L60,30 M60,0 L0,30" clip-path="url(#t)" stroke="#C8102E" stroke-width="4"/>
                            <path d="M30,0 v30 M0,15 h60" stroke="#fff" stroke-width="10"/>
                            <path d="M30,0 v30 M0,15 h60" stroke="#C8102E" stroke-width="6"/></g>
                        </svg>
                    </span>
                </button>
                <button class="theme-toggle" id="themeToggle">üåô</button>
            </div>
        </header>

        <!-- Content -->
        <main class="content">
            <!-- Filter Panel -->
            <section class="section filter-section-mobile">
                <div class="filter-panel filter-panel-mobile">
                    <h3 class="section-title filter-title-mobile" data-i18n="charts.dataFilter">üîß B·ªô l·ªçc d·ªØ li·ªáu</h3>

                    <!-- Quick Time Range Buttons -->
                    <div class="filter-row time-range-row">
                        <label class="form-label mobile-label" data-i18n="charts.quickTimeRange">‚è∞ Kho·∫£ng th·ªùi gian</label>
                        <div class="time-range-buttons">
                            <button class="btn btn-time btn-secondary" onclick="setTimeRange('today')" id="btnToday" data-i18n="common.today">H√¥m nay</button>
                            <button class="btn btn-time btn-primary" onclick="setTimeRange('24h')" id="btn24h" data-i18n="charts.last24h">24h</button>
                            <button class="btn btn-time btn-secondary" onclick="setTimeRange('7d')" id="btn7d" data-i18n="charts.last7d">7 ng√†y</button>
                            <button class="btn btn-time btn-secondary" onclick="setTimeRange('30d')" id="btn30d" data-i18n="charts.last30d">30 ng√†y</button>
                            <button class="btn btn-time btn-secondary" onclick="setTimeRange('custom')" id="btnCustom" data-i18n="charts.custom">üìÖ</button>
                        </div>
                    </div>

                    <!-- Custom Date/Time Range -->
                    <div class="filter-row custom-range-row" id="customRangeRow" style="display: none;">
                        <div class="form-group custom-date-group">
                            <label class="form-label mobile-label">üìÖ <span data-i18n="charts.fromDate">T·ª´</span></label>
                            <input type="datetime-local" class="form-input" id="startDateTime">
                        </div>
                        <div class="form-group custom-date-group">
                            <label class="form-label mobile-label">üìÖ <span data-i18n="charts.toDate">ƒê·∫øn</span></label>
                            <input type="datetime-local" class="form-input" id="endDateTime">
                        </div>
                    </div>

                    <!-- Node and Granularity - Collapsible on mobile -->
                    <details class="filter-details">
                        <summary class="filter-summary">‚öôÔ∏è <span data-i18n="charts.advancedOptions">T√πy ch·ªçn n√¢ng cao</span></summary>
                        <div class="filter-row advanced-filters">
                            <div class="form-group">
                                <label class="form-label mobile-label" data-i18n="charts.node">üìç Node</label>
                                <select class="form-select" id="nodeSelect">
                                    <option value="all" data-i18n="common.all">T·∫•t c·∫£</option>
                                    <option value="node1">Node 1</option>
                                    <option value="node2">Node 2</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label mobile-label" data-i18n="charts.granularity">üìä Chi ti·∫øt</label>
                                <select class="form-select" id="granularitySelect">
                                    <option value="hour" data-i18n="charts.byHour">Theo gi·ªù</option>
                                    <option value="day" data-i18n="charts.byDay">Theo ng√†y</option>
                                    <option value="week" data-i18n="charts.byWeek">Theo tu·∫ßn</option>
                                </select>
                            </div>
                        </div>
                    </details>

                    <!-- Action Buttons -->
                    <div class="filter-row action-buttons-row">
                        <button class="btn btn-primary btn-action" onclick="applyFilters()">
                            üîç <span data-i18n="charts.applyFilter">√Åp d·ª•ng</span>
                        </button>
                        <button class="btn btn-secondary btn-action" onclick="resetFilters()">
                            üîÑ <span data-i18n="charts.resetFilter">ƒê·∫∑t l·∫°i</span>
                        </button>
                    </div>

                    <!-- Time Range Info Display -->
                    <div class="info-panel mt-10" id="timeRangeInfo" style="display: none;">
                        <div class="info-panel-content">
                            <strong>‚è±Ô∏è <span data-i18n="charts.timeRangeViewing">ƒêang xem:</span></strong><br>
                            <span id="timeRangeText"></span>
                        </div>
                    </div>
                </div>
            </section>

            <!-- All Sensors Detailed Charts (Combined - No Separation) -->
            <section class="section charts-section-mobile">
                <div class="section-header-mobile">
                    <h2 class="section-title">üìä <span data-i18n="charts.allSensors">Bi·ªÉu ƒë·ªì c·∫£m bi·∫øn</span></h2>
                    <p class="section-subtitle" data-i18n="charts.allSensorsDesc">D·ªØ li·ªáu IoT & th·ªùi ti·∫øt</p>
                </div>
                <div id="allSensorsChartsGrid" class="charts-grid-responsive">
                    <!-- Detailed charts will be populated by JavaScript -->
                </div>
            </section>

            <!-- Statistics Cards -->
            <section class="section stats-section-mobile">
                <h2 class="section-title">üìà <span data-i18n="charts.statistics">Th·ªëng k√™</span></h2>
                <div class="stats-scroll-container" id="statsContainer">
                    <div class="stats-grid-scroll" id="statsGrid">
                        <!-- Stats will be populated by JavaScript -->
                    </div>
                    <div class="stats-scroll-hint" id="statsScrollHint">
                        <!-- Scroll dots will be added by JS -->
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>

    <!-- Scripts -->
    <script src="/static/js/app.js"></script>
    <script>
        let currentTimeRange = '24h';
        let chartsData = {};
        let customStartDate = null;
        let customEndDate = null;
        let currentGranularity = 'hour';

        // All sensors configuration (IoT + Weather API - NO SEPARATION)
        const allSensors = [
            { key: 'temperature', nameKey: 'charts.sensors.temperature', name: 'Nhi·ªát ƒë·ªô', unit: '¬∞C', color: '#ff6b9d', icon: 'üå°Ô∏è' },
            { key: 'humidity', nameKey: 'charts.sensors.humidity', name: 'ƒê·ªô ·∫©m', unit: '%', color: '#4299e1', icon: 'üíß' },
            { key: 'pressure', nameKey: 'charts.sensors.pressure', name: '√Åp su·∫•t', unit: 'hPa', color: '#f6ad55', icon: 'üéØ' },
            { key: 'co2', nameKey: 'charts.sensors.co2', name: 'CO‚ÇÇ', unit: 'ppm', color: '#68d391', icon: '‚òÅÔ∏è' },
            { key: 'dust', nameKey: 'charts.sensors.dust', name: 'B·ª•i m·ªãn', unit: '¬µg/m¬≥', color: '#b794f4', icon: 'üò∑' },
            { key: 'windSpeed', nameKey: 'charts.sensors.windSpeed', name: 'T·ªëc ƒë·ªô gi√≥', unit: 'km/h', color: '#90cdf4', icon: 'üå¨Ô∏è' },
            { key: 'rainfall', nameKey: 'charts.sensors.rainfall', name: 'L∆∞·ª£ng m∆∞a', unit: 'mm', color: '#63b3ed', icon: 'üåßÔ∏è' },
            { key: 'uvIndex', nameKey: 'charts.sensors.uvIndex', name: 'Ch·ªâ s·ªë UV', unit: '', color: '#fbd38d', icon: '‚òÄÔ∏è' }
        ];
        
        // Helper function to get translated text
        function t(key) {
            if (typeof i18n !== 'undefined' && i18n.t) {
                return i18n.t(key);
            }
            return null;
        }
        
        // Get sensor name with i18n
        function getSensorName(sensor) {
            return t(sensor.nameKey) || sensor.name;
        }

        // Initialize datetime inputs
        function initializeDateTimeInputs() {
            const now = new Date();
            const endDateTime = document.getElementById('endDateTime');
            const startDateTime = document.getElementById('startDateTime');

            endDateTime.value = formatDateTimeLocal(now);
            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            startDateTime.value = formatDateTimeLocal(yesterday);
        }

        function formatDateTimeLocal(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Set time range
        function setTimeRange(range) {
            currentTimeRange = range;

            const buttons = ['btnToday', 'btn24h', 'btn7d', 'btn30d', 'btnCustom'];
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.className = 'btn btn-secondary';
            });

            const btnMap = {
                'today': 'btnToday',
                '24h': 'btn24h',
                '7d': 'btn7d',
                '30d': 'btn30d',
                'custom': 'btnCustom'
            };

            const selectedBtn = document.getElementById(btnMap[range]);
            if (selectedBtn) selectedBtn.className = 'btn btn-primary';

            const customRow = document.getElementById('customRangeRow');
            customRow.style.display = range === 'custom' ? 'flex' : 'none';
        }

        // Reset filters
        function resetFilters() {
            setTimeRange('24h');
            document.getElementById('nodeSelect').value = 'all';
            document.getElementById('granularitySelect').value = 'hour';
            document.getElementById('timeRangeInfo').style.display = 'none';
            applyFilters();
        }

        // Apply filters
        async function applyFilters() {
            currentGranularity = document.getElementById('granularitySelect').value;

            if (currentTimeRange === 'custom') {
                const startInput = document.getElementById('startDateTime').value;
                const endInput = document.getElementById('endDateTime').value;

                if (!startInput || !endInput) {
                    AppUtils.showToast('Vui l√≤ng ch·ªçn ƒë·∫ßy ƒë·ªß ng√†y gi·ªù b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c', 'warning');
                    return;
                }

                customStartDate = new Date(startInput);
                customEndDate = new Date(endInput);

                if (customStartDate >= customEndDate) {
                    AppUtils.showToast('Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i nh·ªè h∆°n ng√†y k·∫øt th√∫c', 'error');
                    return;
                }

                const infoPanel = document.getElementById('timeRangeInfo');
                const infoText = document.getElementById('timeRangeText');
                infoPanel.style.display = 'block';
                infoText.innerHTML = `
                    <strong>T·ª´:</strong> ${customStartDate.toLocaleString('vi-VN')}<br>
                    <strong>ƒê·∫øn:</strong> ${customEndDate.toLocaleString('vi-VN')}<br>
                    <strong>T·ªïng:</strong> ${Math.round((customEndDate - customStartDate) / (1000 * 60 * 60))} gi·ªù
                `;
            } else {
                document.getElementById('timeRangeInfo').style.display = 'none';
            }

            await loadChartsData();
        }

        // Generate weather API data
        function generateWeatherAPIData(sensorKey, dataPoints) {
            const data = [];
            let baseValue;

            switch (sensorKey) {
                case 'windSpeed': baseValue = 12; break;
                case 'rainfall': baseValue = 2; break;
                case 'uvIndex': baseValue = 5; break;
                default: baseValue = 10;
            }

            for (let i = 0; i < dataPoints; i++) {
                const variation = (Math.random() - 0.5) * (baseValue * 0.4);
                const value = Math.max(0, baseValue + variation);
                const timestamp = new Date(Date.now() - (dataPoints - i) * 3600000);

                const dateStr = timestamp.toLocaleDateString('vi-VN', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                });
                const timeStr = timestamp.toLocaleTimeString('vi-VN', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });

                data.push({
                    time: `${dateStr} ${timeStr}`,
                    timestamp: timestamp,
                    value: value.toFixed(1)
                });
            }

            return data;
        }

        // Load all charts data
        async function loadChartsData() {
            const grid = document.getElementById('allSensorsChartsGrid');
            const loading = AppUtils.showLoading(grid);

            try {
                // Fetch all data from API including IoT sensors and weather data
                const allSensorKeys = ['temperature', 'humidity', 'pressure', 'co2', 'dust', 'wind_speed', 'rainfall', 'uv_index'];
                const allData = await AppUtils.fetchChartsData(currentTimeRange, allSensorKeys);

                // Initialize chartsData with proper mapping
                chartsData = {};
                
                // Map sensor data (exact keys from API)
                chartsData['temperature'] = allData.temperature || [];
                chartsData['humidity'] = allData.humidity || [];
                chartsData['pressure'] = allData.pressure || [];
                chartsData['co2'] = allData.co2 || [];
                chartsData['dust'] = allData.dust || [];
                
                // Map weather data (match sensor configuration keys)
                chartsData['windSpeed'] = allData.wind_speed || [];
                chartsData['rainfall'] = allData.rainfall || [];
                chartsData['uvIndex'] = allData.uv_index || [];

                // Debug: log data to console
                console.log('Loaded charts data:', chartsData);
                console.log('Temperature points:', chartsData.temperature.length);
                console.log('Wind speed points:', chartsData.windSpeed.length);

                // Draw all detailed charts
                drawAllDetailedCharts();

                // Update statistics
                updateStatistics();

                AppUtils.showToast('ƒê√£ c·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì th√†nh c√¥ng', 'success');
            } catch (error) {
                console.error('Error loading charts:', error);
                AppUtils.showToast('L·ªói: ' + error.message, 'error');
            } finally {
                AppUtils.hideLoading(loading);
            }
        }

        // Draw all detailed charts in unified grid
        function drawAllDetailedCharts() {
            const grid = document.getElementById('allSensorsChartsGrid');
            grid.innerHTML = '';
            
            const isMobile = window.innerWidth <= 480;
            const isTablet = window.innerWidth <= 768;

            allSensors.forEach(sensor => {
                // Create chart container
                const container = document.createElement('div');
                container.className = 'chart-container';

                // Create header with title and current value
                const header = document.createElement('div');
                header.className = 'chart-header-mobile';

                const title = document.createElement('h3');
                title.className = 'chart-title';
                title.innerHTML = `${sensor.icon} ${getSensorName(sensor)}`;

                // Current value display
                const valueDisplay = document.createElement('div');
                valueDisplay.className = 'chart-value-display';

                if (chartsData[sensor.key] && chartsData[sensor.key].length > 0) {
                    const latest = chartsData[sensor.key][chartsData[sensor.key].length - 1];
                    const currentVal = document.createElement('div');
                    currentVal.className = 'chart-current-value';
                    currentVal.style.color = sensor.color;
                    currentVal.textContent = `${latest.value}${sensor.unit}`;

                    const updateTime = document.createElement('div');
                    updateTime.className = 'chart-update-time';
                    updateTime.textContent = latest.time.split(' ')[1];

                    valueDisplay.appendChild(currentVal);
                    valueDisplay.appendChild(updateTime);
                }

                header.appendChild(title);
                header.appendChild(valueDisplay);

                // Create canvas wrapper for responsive
                const canvasWrapper = document.createElement('div');
                canvasWrapper.className = 'chart-canvas-wrapper';

                // Create canvas for chart
                const canvas = document.createElement('canvas');
                canvas.className = 'chart-canvas-responsive';
                
                // Set explicit height based on device - synced with CSS
                let canvasHeight;
                if (window.innerWidth <= 360) {
                    canvasHeight = 120;
                } else if (isMobile) {
                    canvasHeight = 140;
                } else if (isTablet) {
                    canvasHeight = 160;
                } else {
                    canvasHeight = 180;
                }
                
                // Set canvas CSS size
                canvas.style.width = '100%';
                canvas.style.height = canvasHeight + 'px';
                canvas.style.display = 'block';

                canvasWrapper.appendChild(canvas);
                container.appendChild(header);
                container.appendChild(canvasWrapper);
                grid.appendChild(container);

                // Draw chart after DOM is ready
                if (chartsData[sensor.key] && chartsData[sensor.key].length > 0) {
                    // Use setTimeout to ensure canvas is in DOM and has dimensions
                    setTimeout(() => {
                        const padding = isMobile ? 30 : (isTablet ? 40 : 50);
                        AppUtils.drawLineChart(canvas, chartsData[sensor.key], {
                            color: sensor.color,
                            padding: padding
                        });
                    }, 50);
                }
            });
            
            // Add resize listener for responsive redraw (debounced)
            if (!window.chartsResizeListener) {
                window.chartsResizeListener = true;
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        drawAllDetailedCharts();
                    }, 300);
                });
            }
        }

        // Update statistics
        function updateStatistics() {
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = '';

            allSensors.forEach(sensor => {
                if (!chartsData[sensor.key] || chartsData[sensor.key].length === 0) return;

                const values = chartsData[sensor.key].map(d => parseFloat(d.value));
                const min = Math.min(...values).toFixed(1);
                const max = Math.max(...values).toFixed(1);
                const avg = (values.reduce((a, b) => a + b, 0) / values.length).toFixed(1);

                const statCard = document.createElement('div');
                statCard.className = 'stat-card';
                
                const minLabel = t('charts.min') || 'Th·∫•p nh·∫•t';
                const maxLabel = t('charts.max') || 'Cao nh·∫•t';
                const avgLabel = t('charts.avg') || 'Trung b√¨nh';
                
                statCard.innerHTML = `
                    <div class="stat-label">
                        <span style="font-size: 16px;">${sensor.icon}</span>
                        <span>${getSensorName(sensor)}</span>
                    </div>
                    <div class="stat-values">
                        <div class="stat-row">
                            <span class="stat-row-label">${minLabel}</span>
                            <span class="stat-row-value min">${min} ${sensor.unit}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-row-label">${maxLabel}</span>
                            <span class="stat-row-value max">${max} ${sensor.unit}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-row-label">${avgLabel}</span>
                            <span class="stat-row-value avg">${avg} ${sensor.unit}</span>
                        </div>
                    </div>
                `;
                statsGrid.appendChild(statCard);
            });
            
            // Add scroll indicator dots
            updateScrollIndicator();
            
            // Listen for scroll to update dots
            statsGrid.addEventListener('scroll', updateScrollIndicator);
            
            // Enable mouse drag scrolling
            enableDragScroll(statsGrid);
        }
        
        // Enable drag to scroll for mouse
        function enableDragScroll(element) {
            let isDown = false;
            let startX;
            let scrollLeft;
            
            element.addEventListener('mousedown', (e) => {
                isDown = true;
                element.style.cursor = 'grabbing';
                startX = e.pageX - element.offsetLeft;
                scrollLeft = element.scrollLeft;
            });
            
            element.addEventListener('mouseleave', () => {
                isDown = false;
                element.style.cursor = 'grab';
            });
            
            element.addEventListener('mouseup', () => {
                isDown = false;
                element.style.cursor = 'grab';
            });
            
            element.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                e.preventDefault();
                const x = e.pageX - element.offsetLeft;
                const walk = (x - startX) * 1.5;
                element.scrollLeft = scrollLeft - walk;
            });
        }
        
        // Update scroll indicator dots
        function updateScrollIndicator() {
            const statsGrid = document.getElementById('statsGrid');
            const scrollHint = document.getElementById('statsScrollHint');
            if (!statsGrid || !scrollHint) return;
            
            const cards = statsGrid.querySelectorAll('.stat-card');
            const cardCount = cards.length;
            if (cardCount === 0) return;
            
            // Calculate visible cards and total pages
            const containerWidth = statsGrid.clientWidth;
            const cardWidth = cards[0]?.offsetWidth || 160;
            const gap = 12;
            const visibleCards = Math.floor(containerWidth / (cardWidth + gap)) || 1;
            const totalPages = Math.ceil(cardCount / visibleCards);
            
            // Get current page based on scroll position
            const scrollLeft = statsGrid.scrollLeft;
            const maxScroll = statsGrid.scrollWidth - containerWidth;
            const currentPage = maxScroll > 0 ? Math.round((scrollLeft / maxScroll) * (totalPages - 1)) : 0;
            
            // Create dots
            scrollHint.innerHTML = '';
            for (let i = 0; i < Math.min(totalPages, 8); i++) {
                const dot = document.createElement('span');
                dot.className = 'scroll-dot' + (i === currentPage ? ' active' : '');
                dot.style.cursor = 'pointer';
                dot.onclick = () => {
                    const targetScroll = maxScroll > 0 ? (maxScroll / (totalPages - 1)) * i : 0;
                    statsGrid.scrollTo({ left: targetScroll, behavior: 'smooth' });
                };
                scrollHint.appendChild(dot);
            }
        }
        
        function addStatsScrollButtons() {
            const container = document.getElementById('statsContainer');
            if (!container) return;

            const existingBtn = container.querySelectorAll('.scroll-btn');
            existingBtn.forEach(btn => btn.remove());

            const leftBtn = document.createElement('button');
            leftBtn.className = 'scroll-btn scroll-left';
            leftBtn.innerHTML = '‚ùÆ';
            leftBtn.onclick = () => {
                const grid = document.getElementById('statsGrid');
                grid.scrollBy({ left: -250, behavior: 'smooth' });
            };

            const rightBtn = document.createElement('button');
            rightBtn.className = 'scroll-btn scroll-right';
            rightBtn.innerHTML = '‚ùØ';
            rightBtn.onclick = () => {
                const grid = document.getElementById('statsGrid');
                grid.scrollBy({ left: 250, behavior: 'smooth' });
            };

            container.appendChild(leftBtn);
            container.appendChild(rightBtn);
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', () => {
            initializeDateTimeInputs();
            loadChartsData();
            
            // Listen for language change to refresh charts and stats
            window.addEventListener('languageChanged', () => {
                if (Object.keys(chartsData).length > 0) {
                    drawAllDetailedCharts();
                    updateStatistics();
                }
            });
        });
    </script>
    
    <!-- Page-specific JavaScript -->
    <script src="/static/js/app.js"></script>
    <script src="/static/js/charts.js"></script>
</body>

</html>